# 监控与运维设计

## 1. 监控体系概述

### 1.1 监控目标

- **主动发现问题**：在用户感知前发现并定位系统异常
- **性能分析与优化**：提供数据支持，持续优化系统性能
- **容量规划**：预测系统资源需求，合理规划容量
- **业务趋势分析**：监控核心业务指标，洞察业务发展趋势
- **安全审计**：记录和审计系统操作，保障系统安全

### 1.2 监控原则

- **全栈覆盖**：从基础设施到业务应用的全方位监控
- **实时性**：监控数据采集和展示的延迟控制在分钟级
- **自动化**：自动化监控部署、告警和故障处理
- **可视化**：通过Dashboard直观展示系统运行状态
- **可扩展性**：监控系统支持水平扩展，适应业务增长

### 1.3 监控技术栈

| 类别 | 技术选型 | 说明 |
|------|---------|------|
| 指标监控 | Prometheus | 开源监控和告警系统 |
| 数据可视化 | Grafana | 灵活的监控数据可视化工具 |
| 日志管理 | ELK Stack | 日志收集、存储、分析和展示 |
| 调用链跟踪 | SkyWalking | 分布式应用性能监控系统 |
| 告警管理 | Alertmanager | Prometheus的告警管理组件 |
| 前端监控 | Sentry | 前端错误和性能监控 |

## 2. 监控分层设计

### 2.1 基础设施监控

- **监控对象**：服务器、网络设备、存储设备
- **监控指标**：
  - **CPU**：使用率、负载、上下文切换
  - **内存**：使用率、交换空间、Page Faults
  - **磁盘**：I/O、使用率、inode使用率
  - **网络**：带宽、延迟、丢包率
- **采集工具**：Node Exporter

### 2.2 容器与中间件监控

- **监控对象**：Kubernetes集群、Docker容器、Redis、RocketMQ、PostgreSQL
- **监控指标**：
  - **Kubernetes**：Node状态、Pod数量、资源使用率
  - **Docker**：容器状态、CPU/内存使用
  - **Redis**：内存使用、命中率、连接数、慢查询
  - **RocketMQ**：消息堆积、TPS、延迟
  - **PostgreSQL**：连接数、QPS、慢查询、锁等待
- **采集工具**：cAdvisor, kube-state-metrics, 各中间件的Exporter

### 2.3 应用性能监控 (APM)

- **监控对象**：所有微服务应用
- **监控指标**：
  - **JVM**：堆内存、GC次数和耗时、线程数
  - **接口**：QPS、响应时间、错误率
  - **调用链**：服务间调用拓扑、耗时分析
  - **数据库连接池**：活跃连接数、等待时间
- **采集工具**：SkyWalking Agent

### 2.4 业务监控

- **监控对象**：核心业务流程
- **监控指标**：
  - **用户**：注册数、登录数、活跃用户数
  - **卡密**：生成量、验证量、激活率
  - **交易**：充值额、消费额、提现额
  - **项目**：项目创建数、授权数
- **采集工具**：业务代码埋点，通过Prometheus SDK上报

### 2.5 用户体验监控

- **监控对象**：Web前端应用
- **监控指标**：
  - **性能**：FP, FCP, LCP, TTI等页面加载指标
  - **错误**：JS错误、资源加载错误、API请求错误
  - **用户行为**：PV, UV, 页面停留时间
- **采集工具**：Sentry SDK

## 3. 日志管理体系

### 3.1 日志收集

- **收集工具**：Filebeat
- **部署方式**：在每个Kubernetes Node上部署Filebeat DaemonSet
- **日志源**：应用日志、系统日志、Nginx访问日志

### 3.2 日志处理与存储

- **处理工具**：Logstash
- **处理流程**：日志解析、格式化、数据清洗、字段丰富
- **存储工具**：Elasticsearch
- **存储策略**：按天创建索引，定期归档和删除

### 3.3 日志查询与分析

- **查询工具**：Kibana
- **查询功能**：全文搜索、字段过滤、聚合分析
- **可视化**：创建日志相关的Dashboard

### 3.4 日志规范

- **日志格式**：统一采用JSON格式
- **日志级别**：DEBUG, INFO, WARN, ERROR, FATAL
- **核心字段**：
  - `timestamp`: 时间戳
  - `level`: 日志级别
  - `traceId`: 调用链ID
  - `serviceName`: 服务名
  - `threadName`: 线程名
  - `className`: 类名
  - `message`: 日志内容
  - `stackTrace`: 错误堆栈

```json
{
  "timestamp": "2023-10-27T10:30:00.123Z",
  "level": "ERROR",
  "traceId": "abc-123-def-456",
  "serviceName": "card-service",
  "threadName": "http-nio-8080-exec-1",
  "className": "com.xbc.card.service.CardVerificationService",
  "message": "Card verification failed for cardNo: 123456, reason: card expired",
  "stackTrace": "..."
}
```

## 4. 告警体系设计

### 4.1 告警规则

- **规则定义**：在Prometheus中定义告警规则
- **规则示例**：
  - **服务不可用**：`up{job="my-service"} == 0`
  - **CPU使用率过高**：`node_cpu_seconds_total{mode="idle"} < 20`
  - **接口错误率过高**：`sum(rate(http_requests_total{status=~"5.."}[5m])) / sum(rate(http_requests_total[5m])) > 0.05`
  - **消息堆积**：`rocketmq_broker_tps{topic="my-topic"} > 1000`

### 4.2 告警级别

- **P1 (紧急)**：核心业务中断、大量用户受影响。需要立即响应。
- **P2 (重要)**：系统性能显著下降、非核心业务中断。需要在15分钟内响应。
- **P3 (次要)**：潜在问题、系统资源使用率接近阈值。需要关注并处理。

### 4.3 告警通知

- **通知渠道**：
  - **P1**：电话、短信、钉钉群@all
  - **P2**：钉钉群、邮件
  - **P3**：钉钉群
- **通知内容**：告警名称、级别、对象、内容、持续时间、建议操作
- **告警收敛**：对重复告警进行合并，避免告警风暴

### 4.4 告警处理流程

1. **告警触发**：Prometheus触发告警，发送给Alertmanager
2. **告警分发**：Alertmanager根据规则进行分组、抑制、静默，然后发送通知
3. **告警认领**：值班人员在钉钉群中认领告警
4. **问题排查**：根据告警信息和Dashboard排查问题
5. **问题解决**：修复问题，恢复服务
6. **告警恢复**：系统恢复正常，Alertmanager发送恢复通知
7. **问题复盘**：对P1/P2级别告警进行复盘，总结经验，改进系统

## 5. 运维自动化

### 5.1 CI/CD

- **工具**：Jenkins + GitLab + Kubernetes
- **流水线**：
  1. **代码提交**：开发人员提交代码到GitLab
  2. **自动触发**：GitLab Webhook触发Jenkins流水线
  3. **代码检查**：SonarQube进行静态代码分析
  4. **单元测试**：运行单元测试和集成测试
  5. **构建镜像**：使用Dockerfile构建应用镜像
  6. **推送镜像**：将镜像推送到Harbor镜像仓库
  7. **自动部署**：使用ArgoCD将应用部署到Kubernetes集群

### 5.2 自动化部署

- **部署策略**：
  - **测试环境**：滚动更新
  - **生产环境**：蓝绿部署或金丝雀发布
- **配置管理**：使用Nacos进行动态配置管理
- **版本回滚**：支持一键回滚到上一个稳定版本

### 5.3 弹性伸缩

- **水平伸缩 (HPA)**：根据CPU/内存使用率自动增减Pod数量
- **垂直伸缩 (VPA)**：根据历史资源使用情况自动调整Pod的资源请求
- **集群伸缩 (Cluster Autoscaler)**：根据集群资源需求自动增减Node数量

### 5.4 故障自愈

- **健康检查**：配置Liveness和Readiness探针，自动重启不健康Pod
- **自动恢复**：Deployment控制器自动拉起失败的Pod
- **服务熔断**：Sentinel自动熔断故障服务，防止雪崩
- **自动降级**：高负载时自动降级非核心功能

## 6. 应急预案与演练

### 6.1 应急预案

| 故障场景 | 影响范围 | 应急措施 | 恢复目标 |
|---|---|---|---|
| 单个服务实例宕机 | 单个服务 | Kubernetes自动拉起新实例 | RTO<5分钟 |
| 整个服务不可用 | 单个业务 | 启动备用服务，服务降级 | RTO<15分钟 |
| 数据库主库宕机 | 核心业务 | 自动切换到从库 | RTO<10分钟, RPO<1分钟 |
| Redis集群不可用 | 缓存、会话 | 服务降级，部分功能不可用 | RTO<30分钟 |
| 机房网络故障 | 整个区域 | 流量切换到备用机房 | RTO<1小时 |

### 6.2 故障演练

- **演练周期**：每季度进行一次
- **演练方式**：
  - **桌面演练**：讨论和推演应急预案
  - **实战演练**：在预发布环境注入故障，检验应急预案有效性
- **演练工具**：Chaos Mesh
- **演练目标**：检验预案、发现问题、提升团队应急能力

## 7. 运维组织与流程

### 7.1 运维团队职责

- **SRE团队**：负责系统稳定性、性能、容量和自动化运维
- **DBA团队**：负责数据库管理、优化和备份恢复
- **安全团队**：负责系统安全、漏洞扫描和应急响应

### 7.2 变更管理

- **变更申请**：所有变更需要提交申请，说明变更内容、风险和回滚方案
- **变更评审**：由相关方评审变更方案
- **变更窗口**：在指定的时间窗口进行变更操作
- **变更记录**：记录所有变更操作和结果

### 7.3 事件管理

- **事件定义**：任何可能导致服务中断或质量下降的情况
- **事件响应**：遵循告警处理流程进行响应
- **事件跟踪**：使用Jira等工具跟踪事件处理过程
- **事件报告**：对重要事件生成报告

### 7.4 问题管理

- **问题识别**：从重复发生的事件中识别根本问题
- **问题分析**：组织相关人员进行根因分析（RCA）
- **问题解决**：制定解决方案，并跟踪实施
- **知识库**：将问题和解决方案记录到知识库